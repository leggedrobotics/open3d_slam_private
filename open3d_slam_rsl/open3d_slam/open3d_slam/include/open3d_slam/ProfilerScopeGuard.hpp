#pragma once

#include <string>

#ifdef ENABLE_PROFILING

#include <chrono>
#include <fstream>
#include <mutex>
#include <sstream>
#include <thread>

class ProfilerScopeGuard {
 public:
  ProfilerScopeGuard(const std::string& label, const std::string& csv_path, const std::string& extra_info = "")
      : label_(label), file_path_(csv_path), extra_info_(extra_info) {
    start_time_ = std::chrono::steady_clock::now();
    thread_id_ = std::this_thread::get_id();
  }

  ~ProfilerScopeGuard() {
    const auto end = std::chrono::steady_clock::now();
    const double duration_ms = std::chrono::duration<double, std::milli>(end - start_time_).count();

    std::ostringstream oss;
    oss << label_ << "," << duration_ms << "," << thread_id_ << "," << extra_info_ << "\n";

    std::lock_guard<std::mutex> lock(write_mutex_);
    std::ofstream out(file_path_, std::ios::app);
    if (out.is_open()) {
      if (is_first_write_) {
        out << "Label,Duration(ms),ThreadID,Info\n";
        is_first_write_ = false;
      }
      out << oss.str();
    }
  }

 private:
  std::string label_;
  std::string file_path_;
  std::string extra_info_;
  std::thread::id thread_id_;
  std::chrono::steady_clock::time_point start_time_;

  static inline std::mutex write_mutex_;
  static inline bool is_first_write_;
};

inline bool ProfilerScopeGuard::is_first_write_ = true;

#else  // ENABLE_PROFILING not defined

// No-op version
class ProfilerScopeGuard {
 public:
  ProfilerScopeGuard(const std::string&, const std::string&, const std::string& = "") {}
};

#endif  // ENABLE_PROFILING
